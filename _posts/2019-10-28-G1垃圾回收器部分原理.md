## G1垃圾回收器

### 简介

> G1 GC，全称Garbage-First Garbage Collector，通过-XX:+UseG1GC参数来启用。G1的目标是在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的需求。

#### 参数及意义

| 参数                               | 含义                                                         |
| :--------------------------------- | :----------------------------------------------------------- |
| -XX:G1HeapRegionSize=n             | 设置Region大小，并非最终值                                   |
| -XX:MaxGCPauseMillis               | 设置G1收集过程目标时间，默认值200ms，不是硬性条件            |
| -XX:G1NewSizePercent               | 新生代最小值，默认值5%                                       |
| -XX:G1MaxNewSizePercent            | 新生代最大值，默认值60%                                      |
| -XX:ParallelGCThreads              | STW期间，并行GC线程数                                        |
| -XX:ConcGCThreads=n                | 并发标记阶段，并行执行的线程数                               |
| -XX:InitiatingHeapOccupancyPercent | 设置触发标记周期的 Java 堆占用率阈值。默认值是45%。这里的java堆占比指的是non_young_capacity_bytes，包括old+humongous |

### G1 中的重要概念

#### Region

![img](D:\githubrepository\wangkunSE.github.io\images\jvm\classicjvmstructure.jpg)

> 传统的GC收集器是将连续的内存空间划分为新生代，老年代和永久代（JDK 8去除了永久代，引入了元空间Metaspace），这种划分的特点是各代的存储地址（逻辑地址）是连续的。

![g1 GC内存布局](..\images/jvm\g1collectorpart.png)

> 而G1的各代存储地址是不连续的，每一代都使用了n个不连续的大小相同的Region，每个Region占有一块连续的虚拟内存地址。如上图所示。
>
> 在上图中，有一些**Region**被标记成了H，他代表Humongous，这些Region存储的是大对象（humongous object，H-obj），即大小大于等于region一半的对象。
>
> **H-obj特征**：
>
> - 直接分配到old gen
> - 在global concurrent marking阶段的cleanup 和 full GC阶段回收
> - 在分配H-obj前先检查是否超过 initiating heap occupancy percent（JVM参数，表明希望heap维持总heap的多大占比）和the marking threshold，如果超过就启动global concurrent marking，为的是提早回收，防止 evacuation failures 和 full GC
>
> **为了减少连续H-objs分配对GC的影响，需要把大对象变为普通的对象，建议增大Region size。**
>
> 一个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围从1M到32M，且是2的指数。相关的设置代码如下：
>
> ```c++
> // share/vm/gc_implementation/g1/heapRegion.cpp
> // Minimum region size; we won't go lower than that.
> // We might want to decrease this in the future, to deal with small
> // heaps a bit more efficiently.
> #define MIN_REGION_SIZE  (      1024 * 1024 )
> // Maximum region size; we don't go higher than that. There's a good
> // reason for having an upper bound. We don't want regions to get too
> // large, otherwise cleanup's effectiveness would decrease as there
> // will be fewer opportunities to find totally empty regions after
> // marking.
> #define MAX_REGION_SIZE  ( 32 * 1024 * 1024 )
> // The automatic region size calculation will try to have around this
> // many regions in the heap (based on the min heap size).
> #define TARGET_REGION_NUMBER          2048
> void HeapRegion::setup_heap_region_size(size_t initial_heap_size, size_t max_heap_size) {
>   uintx region_size = G1HeapRegionSize;
>   if (FLAG_IS_DEFAULT(G1HeapRegionSize)) {
>     size_t average_heap_size = (initial_heap_size + max_heap_size) / 2;
>     region_size = MAX2(average_heap_size / TARGET_REGION_NUMBER,
>                        (uintx) MIN_REGION_SIZE);
>   }
>   int region_size_log = log2_long((jlong) region_size);
>   // Recalculate the region size to make sure it's a power of
>   // 2. This means that region_size is the largest power of 2 that's
>   // <= what we've calculated so far.
>   region_size = ((uintx)1 << region_size_log);
>   // Now make sure that we don't go over or under our limits.
>   if (region_size < MIN_REGION_SIZE) {
>     region_size = MIN_REGION_SIZE;
>   } else if (region_size > MAX_REGION_SIZE) {
>     region_size = MAX_REGION_SIZE;
>   }
> }
> ```

#### SATB(Snapshot-At-The-Beginning)

> 意思是GC开始时活着对象的一个快照。通过Root Tracing得到，作用是维持并发GC的正确性。

![img](..\images\jvm\stab.png)

> 由Taiichi Yuasa为增量式标记清除垃圾收集器开发的一个算法，主要应用于垃圾收集的并发标记阶段，解决了CMS垃圾收集器重新标记阶段长时间STW的潜在风险。
>
> 1. 假设第n轮并发标记开始，将该Region当前的top指针赋值给next TAMS，在并发标记标记期间，分配的对象都在[next TAMS, top]之间，SATB能够确保这部分的对象都会被标记，默认都是存活的。
> 2. 当并发标记结束时，将next TAMS所在的地址赋值给previous TAMS，SATB给 [bottom, previous TAMS] 之间的对象创建一个快照Bitmap，所有垃圾对象能通过快照被识别出来
> 3. 第n+1轮并发标记开始，过程和第n轮一样

在G1中主要使用pre-write barrier来存储存活对象。

> 当然，很可能有对象在snapshot中是活的，但随着并发GC的进行它可能本来已经死了，但SATB还是会让它活过这次GC。

### RSet

> 全称是Remembered Set，是辅助GC过程的一种结构，典型的空间换时间工具，和Card Table有些类似。
>
> 还有一种数据结构也是辅助GC的：Collection Set（CSet），它记录了GC要收集的Region集合，集合里的Region可以是任意年代的。在GC的时候，对于old->young和old->old的跨代对象引用，只要扫描对应的CSet中的RSet即可。

![Remembered Sets](..\images\jvm\rset.jpg)

> 上图中有三个Region，每个Region被分成了多个Card，在不同Region中的Card会相互引用，Region1中的Card中的对象引用了Region2中的Card中的对象，蓝色实线表示的就是points-out的关系，而在Region2的RSet中，记录了Region1的Card，即红色虚线表示的关系，这就是points-into。 而维系RSet中的引用关系靠post-write barrier和Concurrent refinement threads来维护

### GC过程

#### GC模式

> - **Young GC**：
>
>   选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。
>
>   
>
> - **Mixed GC**：
>
>   选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。
>
> **由上面的描述可知，Mixed GC不是full GC，它只能回收部分老年代的Region，如果mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（full GC）来收集整个GC heap。所以我们可以知道，G1是不提供full GC的。**

#### global concurrent marking

> 在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。
>
> - **初始标记（initial mark，STW）**:它标记了从GC Root开始直接可达的对象。
> - **并发标记（Concurrent Marking）**:这个阶段从GC Root开始对heap中的对象标记，标记线程与应用程序线程并行执行，并且收集各个Region的存活对象信息。
> - **最终标记（Remark，STW）**:标记那些在并发标记阶段发生变化的对象，将被回收。
> - **清除垃圾（Cleanup）**:清除空Region（没有存活对象的），加入到free list。

#### MIX GC

> MixedGC的发生时机由一些参数控制着，另外控制着哪些老年代Region会被选入Cset。
>
> - G1HeapWastePercent：垃圾大于这个占比就会发生mixed GC。
> - G1MixedGCLiveThresholdPercent：old generation region中的存活对象的占比，只有在此参数之下，才会被选入CSet。
> - G1MixedGCCountTarget：一次global concurrent marking之后，最多执行Mixed GC的次数。
> -  G1OldCSetRegionThresholdPercent：一次Mixed GC中能被选入CSet的最多old generation region数量。

### GC日志

#### Young GC日志

```java
{Heap before GC invocations=12 (full 1):
 garbage-first heap   total 3145728K, used 336645K [0x0000000700000000, 0x00000007c0000000, 0x00000007c0000000)
  region size 1024K, 172 young (176128K), 13 survivors (13312K)
 Metaspace       used 29944K, capacity 30196K, committed 30464K, reserved 1077248K
  class space    used 3391K, capacity 3480K, committed 3584K, reserved 1048576K
2014-11-14T17:57:23.654+0800: 27.884: [GC pause (G1 Evacuation Pause) (young)
Desired survivor size 11534336 bytes, new threshold 15 (max 15)
- age   1:    5011600 bytes,    5011600 total
 27.884: [G1Ergonomics (CSet Construction) start choosing CSet, _pending_cards: 1461, predicted base time: 35.25 ms, remaining time: 64.75 ms, target pause time: 100.00 ms]
 27.884: [G1Ergonomics (CSet Construction) add young regions to CSet, eden: 159 regions, survivors: 13 regions, predicted young region time: 44.09 ms]
 27.884: [G1Ergonomics (CSet Construction) finish choosing CSet, eden: 159 regions, survivors: 13 regions, old: 0 regions, predicted pause time: 79.34 ms, target pause time: 100.00 ms]
, 0.0158389 secs]
   [Parallel Time: 8.1 ms, GC Workers: 4]
      [GC Worker Start (ms): Min: 27884.5, Avg: 27884.5, Max: 27884.5, Diff: 0.1]
      [Ext Root Scanning (ms): Min: 0.4, Avg: 0.8, Max: 1.2, Diff: 0.8, Sum: 3.1]
      [Update RS (ms): Min: 0.0, Avg: 0.3, Max: 0.6, Diff: 0.6, Sum: 1.4]
         [Processed Buffers: Min: 0, Avg: 2.8, Max: 5, Diff: 5, Sum: 11]
      [Scan RS (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.3]
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 0.6]
      [Object Copy (ms): Min: 4.9, Avg: 5.1, Max: 5.2, Diff: 0.3, Sum: 20.4]
      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [GC Worker Other (ms): Min: 0.0, Avg: 0.4, Max: 1.3, Diff: 1.3, Sum: 1.4]
      [GC Worker Total (ms): Min: 6.4, Avg: 6.8, Max: 7.8, Diff: 1.4, Sum: 27.2]
      [GC Worker End (ms): Min: 27891.0, Avg: 27891.3, Max: 27892.3, Diff: 1.3]
   [Code Root Fixup: 0.5 ms]
   [Code Root Migration: 1.3 ms]
   [Code Root Purge: 0.0 ms]
   [Clear CT: 0.2 ms]
   [Other: 5.8 ms]
      [Choose CSet: 0.0 ms]
      [Ref Proc: 5.0 ms]
      [Ref Enq: 0.1 ms]
      [Redirty Cards: 0.0 ms]
      [Free CSet: 0.2 ms]
   [Eden: 159.0M(159.0M)->0.0B(301.0M) Survivors: 13.0M->11.0M Heap: 328.8M(3072.0M)->167.3M(3072.0M)]
Heap after GC invocations=13 (full 1):
 garbage-first heap   total 3145728K, used 171269K [0x0000000700000000, 0x00000007c0000000, 0x00000007c0000000)
  region size 1024K, 11 young (11264K), 11 survivors (11264K)
 Metaspace       used 29944K, capacity 30196K, committed 30464K, reserved 1077248K
  class space    used 3391K, capacity 3480K, committed 3584K, reserved 1048576K
}
 [Times: user=0.05 sys=0.01, real=0.02 secs]
```





### 参考资料

> https://tech.meituan.com/2016/09/23/g1.html
>
> https://www.infoq.com/articles/tuning-tips-G1-GC/
>
> https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All/
>
> https://zhuanlan.zhihu.com/p/52841787
>
> https://www.jianshu.com/p/9e70097807ba