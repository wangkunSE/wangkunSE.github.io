## JVM总结

### 1.类加载机制

#### 1.1类加载时机:

> 加载--> 验证-->准备-->解析—>初始化-->使用—>卸载

##### 初始化的触发时机（主动引用）：

> - new一个新对象，或者调用这个类的静态方法或静态参数时。
> - 对类进行反射调用时
> - 初始化一个类，发现其父类还没有初始化时
> - 当虚拟机启动时，用户指定了一个主类，发现其主类还没有进行初始化时。

#### 1.2类的加载过程：

##### 1.2.1加载 

**所完成的事情**

> 1. 通过一个类的全限定名来获取定义此类的二进制字节流。
> 2. 将这个字节流转化为方法区的运行时数据结构
> 3. 在内存中生成一个代表这个类的java.lang.Class对象。

##### 1.2.2验证

**验证内容**

> 1. 文件格式验证（流—>方法区的数据结构）
> 2. 元数据验证
> 3. 字节码验证
> 4. 符号引用验证

##### 1.2.3准备

> 为类变量分配内存并设置类变量初始值的阶段。

##### 1.2.4解析

> 将符号引用替换为直接引用的过程。

##### 1.2.5初始化

> 执行构造器的过程

### 2.可达性分析算法

> 当一个对象到GC Roots没有任何引用链相连时，就是从GC Roots不可到达这个对象时，这个对象时不可达的。

**在Java中，可以作为GC Roots的对象包括以下几种：**

- 虚拟机栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象

### 3.引用类型

#### 3.1 强引用

> new出来的对象引用。

#### 3.2 软引用

> 有用但非必须的对象，空间足够会留存，不足则会把这些对象做二次回收。

#### 3.3 弱引用

> 即便空间足够也只能生存到下次回收前。

#### 3.4 虚引用

> 紧紧是为了使这样的对象在回收前引用出可收到通知。

#### 3.5对象的自救方法

> finalize()方法。当对象没有覆盖finalize()方法或已经执行过，则不会再执行这个方法。

### 4.垃圾回收算法

#### 4.1标记-清除算法

> 先对不用的对象进行标记，然后统一回收。
>
> **不足:**
>
> - 大量的空间碎片
> - 效率不高

#### 4.2复制算法

> 将内存划分为两块，垃圾回收时将其中一块的有用对象直接移动到另一个区域中，效率高且不会产生碎片。
>
> **不足：**
>
> - 浪费空间

#### 4.3标记-整理算法

> 先标记要回收的对象，然后移动存活对象到一段，最后统一移动到一段。对剩下的东西进行统一清除。

 